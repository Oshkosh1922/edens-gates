// Minimal, production-ready Solana client for Edens Gates vote fees
import { 
  Connection, 
  PublicKey, 
  Transaction, 
  ComputeBudgetProgram,
  TransactionInstruction,
  SystemProgram
} from '@solana/web3.js'
import { 
  getAssociatedTokenAddress, 
  createAssociatedTokenAccountInstruction,
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
} from '@solana/spl-token'

// Types
export type VoteParams = {
  connection: Connection
  wallet: { 
    publicKey: PublicKey
    signTransaction: (tx: Transaction) => Promise<Transaction> 
  }
  programId: PublicKey
  founderUuid: string           // standard UUID v4
  meMint: PublicKey             // $ME mint address
  rewardsOwner: PublicKey       // rewards wallet owner
}

export type RecordVoteParams = {
  supabase: any
  founderId: string
  wallet?: string
  txSig: string
}

// Utils
export function uuidToBytes16(uuid: string): Uint8Array {
  // Remove hyphens and validate format
  const cleaned = uuid.replace(/-/g, '')
  if (cleaned.length !== 32 || !/^[0-9a-f]+$/i.test(cleaned)) {
    throw new Error('Invalid UUID format')
  }
  
  // Convert hex string to bytes (little-endian)
  const bytes = new Uint8Array(16)
  for (let i = 0; i < 16; i++) {
    bytes[i] = parseInt(cleaned.substr(i * 2, 2), 16)
  }
  return bytes
}

export async function getAtaOrCreate(
  connection: Connection,
  owner: PublicKey,
  mint: PublicKey,
  payer: PublicKey = owner
): Promise<{ ata: PublicKey; instruction?: TransactionInstruction }> {
  const ata = await getAssociatedTokenAddress(mint, owner)
  
  try {
    await connection.getTokenAccountBalance(ata)
    return { ata }
  } catch {
    // ATA doesn't exist, create instruction
    const instruction = createAssociatedTokenAccountInstruction(
      payer,
      ata,
      owner,
      mint,
      TOKEN_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID
    )
    return { ata, instruction }
  }
}

// Main vote function
export async function voteWithFee(params: VoteParams): Promise<{ txSig: string }> {
  const { connection, wallet, programId, founderUuid, meMint, rewardsOwner } = params
  
  // Convert UUID to bytes
  const founderBytes = uuidToBytes16(founderUuid)
  
  // Build transaction
  const tx = new Transaction()
  
  // Add compute budget
  tx.add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }),
    ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 1000 })
  )
  
  // Get/create payer's ME ATA
  const { ata: payerMeAta, instruction: payerAtaIx } = await getAtaOrCreate(
    connection,
    wallet.publicKey,
    meMint
  )
  if (payerAtaIx) tx.add(payerAtaIx)
  
  // Get/create rewards ATA
  const { ata: rewardsAta, instruction: rewardsAtaIx } = await getAtaOrCreate(
    connection,
    rewardsOwner,
    meMint,
    wallet.publicKey // payer creates if needed
  )
  if (rewardsAtaIx) tx.add(rewardsAtaIx)
  
  // Build vote_with_fee instruction
  const voteIx = await buildVoteInstruction(
    programId,
    wallet.publicKey,
    payerMeAta,
    meMint,
    rewardsOwner,
    rewardsAta,
    founderBytes
  )
  tx.add(voteIx)
  
  // Set recent blockhash and fee payer
  const { blockhash } = await connection.getLatestBlockhash()
  tx.recentBlockhash = blockhash
  tx.feePayer = wallet.publicKey
  
  // Sign and send
  const signedTx = await wallet.signTransaction(tx)
  const txSig = await connection.sendRawTransaction(signedTx.serialize())
  
  // Confirm
  await connection.confirmTransaction(txSig, 'confirmed')
  
  return { txSig }
}

// Build Anchor instruction
async function buildVoteInstruction(
  programId: PublicKey,
  payer: PublicKey,
  payerMeAta: PublicKey,
  meMint: PublicKey,
  rewardsOwner: PublicKey,
  rewardsAta: PublicKey,
  founderUuid: Uint8Array
): Promise<TransactionInstruction> {
  // Anchor instruction discriminator for vote_with_fee
  // This is a hash of "global:vote_with_fee" - would be generated by Anchor build
  const discriminator = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0])
  
  // Instruction data: discriminator + founder_uuid (16 bytes)
  const data = Buffer.concat([discriminator, Buffer.from(founderUuid)])
  
  // Account keys in order as defined in program
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: payerMeAta, isSigner: false, isWritable: true },
    { pubkey: meMint, isSigner: false, isWritable: false },
    { pubkey: rewardsOwner, isSigner: false, isWritable: false },
    { pubkey: rewardsAta, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
  ]
  
  return new TransactionInstruction({
    keys,
    programId,
    data,
  })
}

// Helper to record vote in Supabase
export async function recordVoteTx(params: RecordVoteParams): Promise<void> {
  const { supabase, founderId, wallet, txSig } = params
  
  const { error } = await supabase
    .from('votes')
    .insert({
      founder_id: founderId,
      wallet: wallet || null,
      tx_sig: txSig,
      ip_hash: null, // Can be set by caller if needed
    })
  
  if (error) {
    throw new Error(`Failed to record vote: ${error.message}`)
  }
}

// Example usage (commented, not executed):
/*
const { txSig } = await voteWithFee({ 
  connection, 
  wallet, 
  programId, 
  founderUuid, 
  meMint, 
  rewardsOwner 
});

await recordVoteTx({ 
  supabase, 
  founderId, 
  wallet: wallet.publicKey.toBase58(), 
  txSig 
});
*/

// Backward compatibility exports
export const getSolanaCluster = (): string => {
  return import.meta.env.VITE_CLUSTER || 'devnet'
}

export const getMeMintAddress = (): PublicKey => {
  const mintStr = import.meta.env.VITE_ME_MINT
  if (!mintStr) {
    throw new Error('VITE_ME_MINT environment variable not set')
  }
  return new PublicKey(mintStr)
}

export const getRewardsVaultAuthority = (): PublicKey => {
  const vaultStr = import.meta.env.VITE_REWARDS_VAULT
  if (!vaultStr) {
    throw new Error('VITE_REWARDS_VAULT environment variable not set')
  }
  return new PublicKey(vaultStr)
}

export const getProgramId = (): PublicKey => {
  return new PublicKey('EGatesVote111111111111111111111111111111111')
}

export const getConnection = (): Connection => {
  const cluster = getSolanaCluster()
  const rpcUrl = cluster === 'mainnet-beta' 
    ? 'https://api.mainnet-beta.solana.com'
    : 'https://api.devnet.solana.com'
  
  return new Connection(rpcUrl, 'confirmed')
}